# Optimal Binary Search Tree (OBST)

## üìå –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏

**Optimal Binary Search Tree (–û–ø—Ç–∏–º–∞–ª—å–Ω–æ–µ –î–≤–æ–∏—á–Ω–æ–µ –î–µ—Ä–µ–≤–æ –ü–æ–∏—Å–∫–∞, OBST)** ‚Äî —ç—Ç–æ –∑–∞–¥–∞—á–∞ –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è –±–∏–Ω–∞—Ä–Ω–æ–≥–æ –¥–µ—Ä–µ–≤–∞ –ø–æ–∏—Å–∫–∞ —Å –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–π –æ–∂–∏–¥–∞–µ–º–æ–π —Å—Ç–æ–∏–º–æ—Å—Ç—å—é –ø–æ–∏—Å–∫–∞.

### –î–∞–Ω–æ:
- `keys[i]` ‚Äî –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∫–ª—é—á–∏  
- `p[i]` ‚Äî –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å —É—Å–ø–µ—à–Ω–æ–≥–æ –ø–æ–∏—Å–∫–∞ –∫–ª—é—á–∞ `i`  
- `q[i]` ‚Äî –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –Ω–µ—É–¥–∞—á–Ω–æ–≥–æ –ø–æ–∏—Å–∫–∞ –º–µ–∂–¥—É –∫–ª—é—á–∞–º–∏  

### –¢—Ä–µ–±—É–µ—Ç—Å—è:
–ü–æ—Å—Ç—Ä–æ–∏—Ç—å BST —Ç–∞–∫, —á—Ç–æ–±—ã **–æ–∂–∏–¥–∞–µ–º–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å –ø–æ–∏—Å–∫–∞** –±—ã–ª–∞ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–π.

---

## üîç –ß—Ç–æ —Ç–∞–∫–æ–µ —Å—Ç–æ–∏–º–æ—Å—Ç—å?

–ö–∞–∂–¥—ã–π –ø–æ–∏—Å–∫ –∏–º–µ–µ—Ç —Å—Ç–æ–∏–º–æ—Å—Ç—å:   cost = —É—Ä–æ–≤–µ–Ω—å —É–∑–ª–∞ * –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –ø–æ–∏—Å–∫–∞

–¶–µ–ª—å OBST ‚Äî –º–∏–Ω–∏–º–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Å—É–º–º—É –≤—Å–µ—Ö —Ç–∞–∫–∏—Ö —Å—Ç–æ–∏–º–æ—Å—Ç–µ–π.

---

## üß† –ò–¥–µ—è —Ä–µ—à–µ–Ω–∏—è (Dynamic Programming)

–ú—ã —Å—Ç—Ä–æ–∏–º –¥–≤–µ —Ç–∞–±–ª–∏—Ü—ã:

### 1. `e[i][j]` ‚Äî –º–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –æ–∂–∏–¥–∞–µ–º–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å –ø–æ–∏—Å–∫–∞ –≤ –ø–æ–¥–¥–µ—Ä–µ–≤–µ –æ—Ç i –¥–æ j  
### 2. `w[i][j]` ‚Äî —Å—É–º–º–∞ –≤—Å–µ—Ö –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–µ–π –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ  
### 3. `root[i][j]` ‚Äî –∏–Ω–¥–µ–∫—Å –∫–æ—Ä–Ω—è –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–≥–æ –ø–æ–¥–¥–µ—Ä–µ–≤–∞

---

## üìå –§–æ—Ä–º—É–ª—ã

### –ë–∞–∑–∞:   e[i][i-1] = q[i-1]
###         w[i][i-1] = q[i-1]

### –û–±—â–∏–π —Å–ª—É—á–∞–π:
### w[i][j] = w[i][j-1] + p[j] + q[j]
### e[i][j] = min(e[i][r-1] + e[r+1][j] + w[i][j]) –ø–æ –≤—Å–µ–º r –æ—Ç i –¥–æ j


---

## üìä –ü—Ä–∏–º–µ—Ä –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö

–ö–ª—é—á–∏:  
k1 < k2 < k3

–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–∏ —É—Å–ø–µ—Ö–∞:  
p = [0.15, 0.10, 0.05]

–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–∏ –Ω–µ—É—Å–ø–µ—Ö–∞:  
q = [0.05, 0.10, 0.05, 0.05]


---

## üìã –¢–∞–±–ª–∏—Ü–∞ –≤–µ—Å–æ–≤ w[i][j]

| i/j | i-1 | i | i+1 |
|-----|-----|----|------|
| w[i][i-1] | q[i-1] |  |   |
| w[i][i]   |        | p[i] + q[i-1] + q[i] |  |
| w[i][i+1] |        |        | p[i] + p[i+1] + q[i-1] + q[i] + q[i+1] |

---

## üßÆ –ü—Ä–∏–º–µ—Ä —Ç–∞–±–ª–∏—Ü—ã e[i][j] –¥–ª—è 3 –∫–ª—é—á–µ–π

| i/j | i-1  | i      | i+1        |
|-----|-------|---------|-------------|
| e[i][i-1] | q[i-1] |         |             |
| e[i][i]   |        | p[i] + q[i] + q[i-1] | |
| e[i][i+1] |        |         | min over roots |

---

## üßë‚Äçüíª –ü–æ–ª–Ω—ã–π Python-–∫–æ–¥ 

```python
def optimal_bst(p, q, n):
    """
    Optimal Binary Search Tree Dynamic Programming Solution

    Args:
        p (list): Probabilities of successful searches (length n)
        q (list): Probabilities of unsuccessful searches (length n+1)
        n (int): Number of keys

    Returns:
        e (2D list): DP table of expected costs
        root (2D list): Table of roots
    """

    # DP tables
    e = [[0] * (n + 1) for _ in range(n + 2)]
    w = [[0] * (n + 1) for _ in range(n + 2)]
    root = [[0] * (n + 1) for _ in range(n + 2)]

    # Initialize base cases
    for i in range(1, n + 2):
        e[i][i - 1] = q[i - 1]
        w[i][i - 1] = q[i - 1]

    # Main DP computation
    for length in range(1, n + 1):
        for i in range(1, n - length + 2):
            j = i + length - 1
            e[i][j] = float("inf")

            # Compute w[i][j]
            w[i][j] = w[i][j - 1] + p[j - 1] + q[j]

            # Try all possible roots r
            for r in range(i, j + 1):
                cost = e[i][r - 1] + e[r + 1][j] + w[i][j]

                if cost < e[i][j]:
                    e[i][j] = cost
                    root[i][j] = r

    return e, root


# Example usage
if __name__ == "__main__":
    p = [0.15, 0.10, 0.05]
    q = [0.05, 0.10, 0.05, 0.05]
    n = len(p)

    e, root = optimal_bst(p, q, n)

    print("Expected Cost Table (e):")
    for row in e:
        print(row)

    print("\nRoot Table:")
    for row in root:
        print(row)

## üß™ –ü—Ä–∏–º–µ—Ä —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞

### –¢–∞–±–ª–∏—Ü–∞ –∫–æ—Ä–Ω–µ–π (`root[i][j]`)
–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç, –∫–∞–∫–æ–π –∫–ª—é—á —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –∫–æ—Ä–Ω–µ–º –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–≥–æ –ø–æ–¥–¥–µ—Ä–µ–≤–∞ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –¥–∏–∞–ø–∞–∑–æ–Ω–∞.

| i\j   | 0 | 1 | 2 | 3 |
|-------|---|---|---|---|
| **0** | 0 | 0 | 0 | 0 |
| **1** | 0 | 1 | 1 | 2 |
| **2** | 0 | 0 | 2 | 2 |
| **3** | 0 | 0 | 0 | 3 |

### –ì–ª–∞–≤–Ω—ã–π –∫–æ—Ä–µ–Ω—å:
root[1][n] = 2


–°–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ, –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–µ –±–∏–Ω–∞—Ä–Ω–æ–µ –¥–µ—Ä–µ–≤–æ –ø–æ–∏—Å–∫–∞ –∏–º–µ–µ—Ç **k‚ÇÇ** –∫–∞–∫ –∫–æ—Ä–Ω–µ–≤–æ–π —É–∑–µ–ª.

---

## üß® –°–ª–æ–∂–Ω–æ—Å—Ç—å –∞–ª–≥–æ—Ä–∏—Ç–º–∞

### ‚è± –í—Ä–µ–º—è: `O(n¬≥)`
- –¢—Ä–∏ –≤–ª–æ–∂–µ–Ω–Ω—ã—Ö —Ü–∏–∫–ª–∞ `i`, `j`, `r`
- –î–ª—è –∫–∞–∂–¥–æ–≥–æ –¥–∏–∞–ø–∞–∑–æ–Ω–∞ –ø–µ—Ä–µ–±–∏—Ä–∞—é—Ç—Å—è –≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ –∫–æ—Ä–Ω–∏

### üíæ –ü–∞–º—è—Ç—å: `O(n¬≤)`
- –ò—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è dp-—Ç–∞–±–ª–∏—Ü—ã: `e`, `w`, `root`

---

## üéâ –ò—Ç–æ–≥

**Optimal Binary Search Tree (OBST)** ‚Äî —ç—Ç–æ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞, –º–∏–Ω–∏–º–∏–∑–∏—Ä—É—é—â–∞—è —Å—Ä–µ–¥–Ω—é—é —Å—Ç–æ–∏–º–æ—Å—Ç—å –ø–æ–∏—Å–∫–∞, –∫–æ–≥–¥–∞ –∑–∞—Ä–∞–Ω–µ–µ –∏–∑–≤–µ—Å—Ç–Ω—ã –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–∏ —É—Å–ø–µ—à–Ω—ã—Ö –∏ –Ω–µ—É—Å–ø–µ—à–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤.

–ê–ª–≥–æ—Ä–∏—Ç–º –æ–ø–∏—Ä–∞–µ—Ç—Å—è –Ω–∞ **–¥–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–µ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ** –∏ —à–∏—Ä–æ–∫–æ –ø—Ä–∏–º–µ–Ω—è–µ—Ç—Å—è –≤:
- –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–∞—Ö  
- –∏–Ω–¥–µ–∫—Å–∞—Ö –±–∞–∑ –¥–∞–Ω–Ω—ã—Ö  
- —Å–∏—Å—Ç–µ–º–∞—Ö –∞–≤—Ç–æ–¥–æ–ø–æ–ª–Ω–µ–Ω–∏—è  
- –¥–µ—Ä–µ–≤—å—è—Ö –ø–æ–∏—Å–∫–∞ —Å –Ω–µ—Ä–∞–≤–Ω–æ–º–µ—Ä–Ω–æ–π —á–∞—Å—Ç–æ—Ç–æ–π –¥–æ—Å—Ç—É–ø–∞  

–û–Ω —è–≤–ª—è–µ—Ç—Å—è –∫–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–º –ø—Ä–∏–º–µ—Ä–æ–º –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä –¥–∞–Ω–Ω—ã—Ö.



